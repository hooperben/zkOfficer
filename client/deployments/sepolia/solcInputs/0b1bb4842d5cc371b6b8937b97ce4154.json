{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/merkle/plonk_vk.sol": {
      "content": "// Verification Key Hash: 71694cf648e482f96e94127d20ca0e173617b22570a9d1f1cad8495287021080\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec\npragma solidity >=0.8.4;\n\nlibrary UltraVerificationKey {\n    function verificationKeyHash() internal pure returns(bytes32) {\n        return 0x71694cf648e482f96e94127d20ca0e173617b22570a9d1f1cad8495287021080;\n    }\n\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\n        assembly {\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000008000) // vk.circuit_size\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000002) // vk.num_inputs\n            mstore(add(_vk, 0x40), 0x2d1ba66f5941dc91017171fa69ec2bd0022a2a2d4115a009a93458fd4e26ecfb) // vk.work_root\n            mstore(add(_vk, 0x60), 0x3063edaa444bddc677fcd515f614555a777997e0a9287d1e62bf6dd004d82001) // vk.domain_inverse\n            mstore(add(_vk, 0x80), 0x2e19547b90e7e9493a39762be65ab75f99a56816473aa9741a58471fc4bf95df) // vk.Q1.x\n            mstore(add(_vk, 0xa0), 0x2b22c31e58a68cef9ad84a97552c207cd794e6e94fcba989b89ef54ac6e61635) // vk.Q1.y\n            mstore(add(_vk, 0xc0), 0x25f7263cce4ea6c78dca1554e971e592470452963b9a27eb73b0c999413fb413) // vk.Q2.x\n            mstore(add(_vk, 0xe0), 0x2610f9bff18f1384dd1a224f8bf008c63ee5027b216fd9656cd7db1902503ad7) // vk.Q2.y\n            mstore(add(_vk, 0x100), 0x084bf4a8cb6537819adbceb2f287cf8a393b329c417907cb8b956ee49da14bed) // vk.Q3.x\n            mstore(add(_vk, 0x120), 0x25b16fc680c00ac27924bed5b34e10fc1a8c1bdf11b33ed2161e7593e6aa5a1f) // vk.Q3.y\n            mstore(add(_vk, 0x140), 0x2a1a4064bc6ef924bed1e22784c9d45441b37b332af09988d2f7be7c008be355) // vk.Q4.x\n            mstore(add(_vk, 0x160), 0x29b121efdfb14341241f24629e5f0940311477193ffd0718d7fbf983920862f0) // vk.Q4.y\n            mstore(add(_vk, 0x180), 0x1ef7e31ccd2c8312d8edace294e05828e581bed95a143c1cd63662ffb157f7c5) // vk.Q_M.x\n            mstore(add(_vk, 0x1a0), 0x22403ada4995009f1856a05ca2e131fcd6609afedce03b359584de70bf0e795f) // vk.Q_M.y\n            mstore(add(_vk, 0x1c0), 0x2527b96b2bc6d82c09c8cc0b2cf63e1edde2535cb7d610e18dd7e80563211458) // vk.Q_C.x\n            mstore(add(_vk, 0x1e0), 0x10ececba23b9eb3d30da4fd2d1019e0c148632a563a6aaf6b3af8ff4c4cf678d) // vk.Q_C.y\n            mstore(add(_vk, 0x200), 0x0fdccadfb79fed6cdf8427f28968bf13d0fb1e502890628dcc56c83df429a602) // vk.Q_ARITHMETIC.x\n            mstore(add(_vk, 0x220), 0x03290cf8f37966efb21d358a3f683d1d0fb28ff09f05d4b7f7b0df77aa6f8431) // vk.Q_ARITHMETIC.y\n            mstore(add(_vk, 0x240), 0x17de1ad04387d41136801f4a1b8ed7ac6147858366cce063f6820f5229cc10ca) // vk.QSORT.x\n            mstore(add(_vk, 0x260), 0x2af0a108ed7faa4f4e968b871de1d39983518b22bcd43ff0c98bf36892763dd9) // vk.QSORT.y\n            mstore(add(_vk, 0x280), 0x21959276775cd4749236c8bf773a9b2403cecb45fbf70e6439f73d75442e8850) // vk.Q_ELLIPTIC.x\n            mstore(add(_vk, 0x2a0), 0x017714509f01d1a9ee7ebaf4d50745e33a14150b4fe9850a27e44de56d88cb14) // vk.Q_ELLIPTIC.y\n            mstore(add(_vk, 0x2c0), 0x2e76c4474fcb457db84fb273ccc10a4647a1a37444369f2f275bb74540f5e2d0) // vk.Q_AUX.x\n            mstore(add(_vk, 0x2e0), 0x209035caddd02a78acd0ed617a85d782533bd142c6cad8e3338f3142b919c3a4) // vk.Q_AUX.y\n            mstore(add(_vk, 0x300), 0x06c27d5d2aa2446e70c19b0e93bc1112ff36b8038f3bd9f5dbbbf0fadbc67c59) // vk.SIGMA1.x\n            mstore(add(_vk, 0x320), 0x0f86f7ea6ae4ee794134e9a36dca4946ffb9e45979641e3ff4984bdb0e240f31) // vk.SIGMA1.y\n            mstore(add(_vk, 0x340), 0x2bc76ee49388ec20f0b74e76c780141aa763044a1d8810b0cf5fd4ce1f05bf26) // vk.SIGMA2.x\n            mstore(add(_vk, 0x360), 0x2a656afac522e4e85d5dae37c96afcaa66dc448f8707bc337f2db52d17525b12) // vk.SIGMA2.y\n            mstore(add(_vk, 0x380), 0x062ae85b81ce0bdb013735c4a634bbbb2ed16bea82991496fd0e94f343e3dc21) // vk.SIGMA3.x\n            mstore(add(_vk, 0x3a0), 0x129e5662268ba66b840af739f303259e6f9163a9eaca8e2e79647da12c4307c0) // vk.SIGMA3.y\n            mstore(add(_vk, 0x3c0), 0x0cb7ba8f1c0ff10e4bdcffc6eb23f63efcd1df7a5f943ad501851e9ab72251f0) // vk.SIGMA4.x\n            mstore(add(_vk, 0x3e0), 0x2b16cd4d6a81d640f5464ef35ba1a966544e5ebc5b55403ebdc954988ab5550e) // vk.SIGMA4.y\n            mstore(add(_vk, 0x400), 0x0c14de0a66a29fef89dd6b25fd3dad2c934048825338d32c9be06295d6895cd3) // vk.TABLE1.x\n            mstore(add(_vk, 0x420), 0x27e139fd5f94a95aed910fc16c4497e04e258a714b90ff5b7cb6a25af764b552) // vk.TABLE1.y\n            mstore(add(_vk, 0x440), 0x2d283760e83465149e358f2910d2515f4df4e281eb18f1ef89f9ad7e72bbf9bf) // vk.TABLE2.x\n            mstore(add(_vk, 0x460), 0x1e7bc1bdd03c522b54abfc3879fea26bcda8b544a524e1ca08ef3d5c5f615c06) // vk.TABLE2.y\n            mstore(add(_vk, 0x480), 0x26ac63c1f22adb0e7f8bbcb49f009546c50d24b1247a743a505416bd4bf12e27) // vk.TABLE3.x\n            mstore(add(_vk, 0x4a0), 0x1542e08ee844541bb7f00b5d7e456b1454a0f66a8793e87ee99a04b4686631b1) // vk.TABLE3.y\n            mstore(add(_vk, 0x4c0), 0x2c5519e9f4218e2873b91dacf2c455670a5bbbd72ce413230f8b88aea0b1cda8) // vk.TABLE4.x\n            mstore(add(_vk, 0x4e0), 0x207960ab6d379cbcdd1ec8b7d562f474d2df14bcf4faa4346a82d4dcbba683dd) // vk.TABLE4.y\n            mstore(add(_vk, 0x500), 0x254c7c79f29e6f05184889d52a7c01375832d53ea8dd60b93162a5805d715657) // vk.TABLE_TYPE.x\n            mstore(add(_vk, 0x520), 0x23558713233600d8847c983db3c2771210aad83fc39e33f4821c4b483fe579c1) // vk.TABLE_TYPE.y\n            mstore(add(_vk, 0x540), 0x0ec0c44b1ebe4a5fb81bf42d5c549ba50bd77efc4fb9f7eb09df2daee685ecba) // vk.ID1.x\n            mstore(add(_vk, 0x560), 0x05fd733ba1e174baa968fb8bb0c8597cbf5736d4fe52c0481d49cb85b45d0f1a) // vk.ID1.y\n            mstore(add(_vk, 0x580), 0x0d01bbf93a42cd1b979252a21e5438a9a62261ca50b8a76a698942330d249fd4) // vk.ID2.x\n            mstore(add(_vk, 0x5a0), 0x06097c2eb9beedd3f7255e75d911e5d9d9809032515ece907ed6aa13df2d4e1a) // vk.ID2.y\n            mstore(add(_vk, 0x5c0), 0x2ebd4870848c25e515e9e753fd2679ec1dbc08cf25d5b1db853e9657738a4028) // vk.ID3.x\n            mstore(add(_vk, 0x5e0), 0x0b033078d1cae15579825b01878d81a31d14da4b8f98edf132362f6ff0c70223) // vk.ID3.y\n            mstore(add(_vk, 0x600), 0x2eea648c8732596b1314fe2a4d2f05363f0c994e91cecad25835338edee2294f) // vk.ID4.x\n            mstore(add(_vk, 0x620), 0x0ab49886c2b94bd0bd3f6ed1dbbe2cb2671d2ae51d31c1210433c3972bb64578) // vk.ID4.y\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \n            mstore(_omegaInverseLoc, 0x05d33766e4590b3722701b6f2fa43d0dc3f028424d384e68c92a742fb2dbc0b4) // vk.work_root_inverse\n        }\n    }\n}\n\n/**\n * @title Ultra Plonk proof verification contract\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\n */\nabstract contract BaseUltraVerifier {\n    // VERIFICATION KEY MEMORY LOCATIONS\n    uint256 internal constant N_LOC = 0x380;\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\n    uint256 internal constant OMEGA_LOC = 0x3c0;\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\n    uint256 internal constant Q1_X_LOC = 0x400;\n    uint256 internal constant Q1_Y_LOC = 0x420;\n    uint256 internal constant Q2_X_LOC = 0x440;\n    uint256 internal constant Q2_Y_LOC = 0x460;\n    uint256 internal constant Q3_X_LOC = 0x480;\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\n    uint256 internal constant Q4_X_LOC = 0x4c0;\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\n    uint256 internal constant QM_X_LOC = 0x500;\n    uint256 internal constant QM_Y_LOC = 0x520;\n    uint256 internal constant QC_X_LOC = 0x540;\n    uint256 internal constant QC_Y_LOC = 0x560;\n    uint256 internal constant QARITH_X_LOC = 0x580;\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\n    uint256 internal constant QAUX_X_LOC = 0x640;\n    uint256 internal constant QAUX_Y_LOC = 0x660;\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\n    uint256 internal constant TABLE1_X_LOC = 0x780;\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\n    uint256 internal constant TABLE3_X_LOC = 0x800;\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\n    uint256 internal constant TABLE4_X_LOC = 0x840;\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\n    uint256 internal constant ID1_X_LOC = 0x8c0;\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\n    uint256 internal constant ID2_X_LOC = 0x900;\n    uint256 internal constant ID2_Y_LOC = 0x920;\n    uint256 internal constant ID3_X_LOC = 0x940;\n    uint256 internal constant ID3_Y_LOC = 0x960;\n    uint256 internal constant ID4_X_LOC = 0x980;\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\n    uint256 internal constant G2X_X0_LOC = 0xa00;\n    uint256 internal constant G2X_X1_LOC = 0xa20;\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\n\n    // ### PROOF DATA MEMORY LOCATIONS\n    uint256 internal constant W1_X_LOC = 0x1200;\n    uint256 internal constant W1_Y_LOC = 0x1220;\n    uint256 internal constant W2_X_LOC = 0x1240;\n    uint256 internal constant W2_Y_LOC = 0x1260;\n    uint256 internal constant W3_X_LOC = 0x1280;\n    uint256 internal constant W3_Y_LOC = 0x12a0;\n    uint256 internal constant W4_X_LOC = 0x12c0;\n    uint256 internal constant W4_Y_LOC = 0x12e0;\n    uint256 internal constant S_X_LOC = 0x1300;\n    uint256 internal constant S_Y_LOC = 0x1320;\n    uint256 internal constant Z_X_LOC = 0x1340;\n    uint256 internal constant Z_Y_LOC = 0x1360;\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\n    uint256 internal constant T1_X_LOC = 0x13c0;\n    uint256 internal constant T1_Y_LOC = 0x13e0;\n    uint256 internal constant T2_X_LOC = 0x1400;\n    uint256 internal constant T2_Y_LOC = 0x1420;\n    uint256 internal constant T3_X_LOC = 0x1440;\n    uint256 internal constant T3_Y_LOC = 0x1460;\n    uint256 internal constant T4_X_LOC = 0x1480;\n    uint256 internal constant T4_Y_LOC = 0x14a0;\n\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\n    uint256 internal constant S_EVAL_LOC = 0x1680;\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\n\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\n\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\n\n    // ### CHALLENGES MEMORY OFFSETS\n\n    uint256 internal constant C_BETA_LOC = 0x2600;\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\n    uint256 internal constant C_ETA_LOC = 0x2660;\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\n\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\n    uint256 internal constant C_V0_LOC = 0x2700;\n    uint256 internal constant C_V1_LOC = 0x2720;\n    uint256 internal constant C_V2_LOC = 0x2740;\n    uint256 internal constant C_V3_LOC = 0x2760;\n    uint256 internal constant C_V4_LOC = 0x2780;\n    uint256 internal constant C_V5_LOC = 0x27a0;\n    uint256 internal constant C_V6_LOC = 0x27c0;\n    uint256 internal constant C_V7_LOC = 0x27e0;\n    uint256 internal constant C_V8_LOC = 0x2800;\n    uint256 internal constant C_V9_LOC = 0x2820;\n    uint256 internal constant C_V10_LOC = 0x2840;\n    uint256 internal constant C_V11_LOC = 0x2860;\n    uint256 internal constant C_V12_LOC = 0x2880;\n    uint256 internal constant C_V13_LOC = 0x28a0;\n    uint256 internal constant C_V14_LOC = 0x28c0;\n    uint256 internal constant C_V15_LOC = 0x28e0;\n    uint256 internal constant C_V16_LOC = 0x2900;\n    uint256 internal constant C_V17_LOC = 0x2920;\n    uint256 internal constant C_V18_LOC = 0x2940;\n    uint256 internal constant C_V19_LOC = 0x2960;\n    uint256 internal constant C_V20_LOC = 0x2980;\n    uint256 internal constant C_V21_LOC = 0x29a0;\n    uint256 internal constant C_V22_LOC = 0x29c0;\n    uint256 internal constant C_V23_LOC = 0x29e0;\n    uint256 internal constant C_V24_LOC = 0x2a00;\n    uint256 internal constant C_V25_LOC = 0x2a20;\n    uint256 internal constant C_V26_LOC = 0x2a40;\n    uint256 internal constant C_V27_LOC = 0x2a60;\n    uint256 internal constant C_V28_LOC = 0x2a80;\n    uint256 internal constant C_V29_LOC = 0x2aa0;\n    uint256 internal constant C_V30_LOC = 0x2ac0;\n\n    uint256 internal constant C_U_LOC = 0x2b00;\n\n    // ### LOCAL VARIABLES MEMORY OFFSETS\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\n    uint256 internal constant L_START_LOC = 0x30a0;\n    uint256 internal constant L_END_LOC = 0x30c0;\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\n\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\n\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\n\n    // misc stuff\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3300;\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3320;\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3340;\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3360;\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3380;\n\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3400;\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3420;\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3440;\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3460;\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3480;\n\n    // sub-identity storage\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3500;\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3520;\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3540;\n    uint256 internal constant SORT_IDENTITY = 0x3560;\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3580;\n    uint256 internal constant AUX_IDENTITY = 0x35a0;\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x35c0;\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x35e0;\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3600;\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3620;\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3640;\n\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3660;\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3680;\n\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x36a0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x36c0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x36e0;\n\n    bytes4 internal constant INVALID_VERIFICATION_KEY_SELECTOR = 0x7e5769bf;\n    bytes4 internal constant POINT_NOT_ON_CURVE_SELECTOR = 0xa3dad654;\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\n    bytes4 internal constant PAIRING_PREAMBLE_FAILED_SELECTOR = 0x01882d81;\n    bytes4 internal constant OPENING_COMMITMENT_FAILED_SELECTOR = 0x4e719763;\n    bytes4 internal constant PAIRING_FAILED_SELECTOR = 0xd71fd263;\n\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\n\n    // We need to hash 41 field elements when generating the NU challenge\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\n\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\n\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\n\n    // y^2 = x^3 + ax + b\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\n\n    error INVALID_VERIFICATION_KEY();\n    error POINT_NOT_ON_CURVE();\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\n    error PUBLIC_INPUT_GE_P();\n    error MOD_EXP_FAILURE();\n    error PAIRING_PREAMBLE_FAILED();\n    error OPENING_COMMITMENT_FAILED();\n    error PAIRING_FAILED();\n\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\n\n    /**\n     * @dev We assume that the verification key loaded by this function is constant as we only verify it on deployment\n     */\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\n\n    constructor() { \n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\n\n        // We verify that all of the EC points in the verification key lie on the bn128 curve. \n        assembly {\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\n\n            let success := 1\n\n            // VALIDATE Q1\n            {\n                let x := mload(Q1_X_LOC)\n                let y := mload(Q1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q2\n            {\n                let x := mload(Q2_X_LOC)\n                let y := mload(Q2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q3\n            {\n                let x := mload(Q3_X_LOC)\n                let y := mload(Q3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q4\n            {\n                let x := mload(Q4_X_LOC)\n                let y := mload(Q4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            // VALIDATE QM\n            {\n                let x := mload(QM_X_LOC)\n                let y := mload(QM_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QC\n            {\n                let x := mload(QC_X_LOC)\n                let y := mload(QC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QARITH\n            {\n                let x := mload(QARITH_X_LOC)\n                let y := mload(QARITH_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QSORT\n            {\n                let x := mload(QSORT_X_LOC)\n                let y := mload(QSORT_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QELLIPTIC\n            {\n                let x := mload(QELLIPTIC_X_LOC)\n                let y := mload(QELLIPTIC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QAUX\n            {\n                let x := mload(QAUX_X_LOC)\n                let y := mload(QAUX_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA1\n            {\n                let x := mload(SIGMA1_X_LOC)\n                let y := mload(SIGMA1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA2\n            {\n                let x := mload(SIGMA2_X_LOC)\n                let y := mload(SIGMA2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA3\n            {\n                let x := mload(SIGMA3_X_LOC)\n                let y := mload(SIGMA3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA4\n            {\n                let x := mload(SIGMA4_X_LOC)\n                let y := mload(SIGMA4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE TABLE1\n            {\n                let x := mload(TABLE1_X_LOC)\n                let y := mload(TABLE1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE2\n            {\n                let x := mload(TABLE2_X_LOC)\n                let y := mload(TABLE2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE3\n            {\n                let x := mload(TABLE3_X_LOC)\n                let y := mload(TABLE3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE4\n            {\n                let x := mload(TABLE4_X_LOC)\n                let y := mload(TABLE4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE_TYPE\n            {\n                let x := mload(TABLE_TYPE_X_LOC)\n                let y := mload(TABLE_TYPE_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID1\n            {\n                let x := mload(ID1_X_LOC)\n                let y := mload(ID1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID2\n            {\n                let x := mload(ID2_X_LOC)\n                let y := mload(ID2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID3\n            {\n                let x := mload(ID3_X_LOC)\n                let y := mload(ID3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID4\n            {\n                let x := mload(ID4_X_LOC)\n                let y := mload(ID4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n\n            if iszero(success) {\n                mstore(0x0, INVALID_VERIFICATION_KEY_SELECTOR)\n                revert(0x00, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Verify a Ultra Plonk proof\n     * @param _proof - The serialized proof\n     * @param _publicInputs - An array of the public inputs\n     * @return True if proof is valid, reverts otherwise\n     */\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\n\n        uint256 requiredPublicInputCount;\n        assembly {\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\n        }\n        if (requiredPublicInputCount != _publicInputs.length) {\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\n        }\n\n        assembly {\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\n\n            /**\n             * LOAD PROOF FROM CALLDATA\n             */\n            {\n                let data_ptr := add(calldataload(0x04), 0x24)\n\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\n\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\n\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\n\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\n\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\n\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\n\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\n\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\n\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\n\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\n\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\n\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\n\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\n\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\n\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\n\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\n\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\n\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\n            }\n\n            /**\n             * LOAD RECURSIVE PROOF INTO MEMORY\n             */\n            {\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\n\n                    let x0 := calldataload(index_counter)\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\n                    let y0 := calldataload(add(index_counter, 0x80))\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\n                    let x1 := calldataload(add(index_counter, 0x100))\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\n                    let y1 := calldataload(add(index_counter, 0x180))\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\n                    mstore(RECURSIVE_P1_X_LOC, x0)\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\n                    mstore(RECURSIVE_P2_X_LOC, x1)\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\n\n                    // validate these are valid bn128 G1 points\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                }\n            }\n\n            {\n                /**\n                 * Generate initial challenge\n                 */\n                mstore(0x00, shl(224, mload(N_LOC)))\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\n                let challenge := keccak256(0x00, 0x08)\n\n                /**\n                 * Generate eta challenge\n                 */\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\n                let public_inputs_start := add(calldataload(0x24), 0x24)\n                // copy the public inputs over\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\n\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\n                let w_start := add(calldataload(0x04), 0x24)\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\n\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\n\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\n                {\n                    let eta := mod(challenge, p)\n                    mstore(C_ETA_LOC, eta)\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\n                }\n\n                /**\n                 * Generate beta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(W4_Y_LOC))\n                mstore(0x40, mload(W4_X_LOC))\n                mstore(0x60, mload(S_Y_LOC))\n                mstore(0x80, mload(S_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_BETA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate gamma challenge\n                 */\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_GAMMA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate alpha challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(Z_Y_LOC))\n                mstore(0x40, mload(Z_X_LOC))\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_ALPHA_LOC, mod(challenge, p))\n\n                /**\n                 * Compute and store some powers of alpha for future computations\n                 */\n                let alpha := mload(C_ALPHA_LOC)\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\n                mstore(C_ALPHA_BASE_LOC, alpha)\n\n                /**\n                 * Generate zeta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(T1_Y_LOC))\n                mstore(0x40, mload(T1_X_LOC))\n                mstore(0x60, mload(T2_Y_LOC))\n                mstore(0x80, mload(T2_X_LOC))\n                mstore(0xa0, mload(T3_Y_LOC))\n                mstore(0xc0, mload(T3_X_LOC))\n                mstore(0xe0, mload(T4_Y_LOC))\n                mstore(0x100, mload(T4_X_LOC))\n\n                challenge := keccak256(0x00, 0x120)\n\n                mstore(C_ZETA_LOC, mod(challenge, p))\n                mstore(C_CURRENT_LOC, challenge)\n            }\n\n            /**\n             * EVALUATE FIELD OPERATIONS\n             */\n\n            /**\n             * COMPUTE PUBLIC INPUT DELTA\n             * ΔPI = ∏ᵢ∈ℓ(wᵢ + β σ(i) + γ) / ∏ᵢ∈ℓ(wᵢ + β σ'(i) + γ)\n             */\n            {\n                let beta := mload(C_BETA_LOC) // β\n                let gamma := mload(C_GAMMA_LOC) // γ\n                let work_root := mload(OMEGA_LOC) // ω\n                let numerator_value := 1\n                let denominator_value := 1\n\n                let p_clone := p // move p to the front of the stack\n                let valid_inputs := true\n\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\n\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\n\n                // root_1 = β * 0x05\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.β\n                // root_2 = β * 0x0c\n                let root_2 := mulmod(beta, 0x0c, p_clone)\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\n\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\n                    /**\n                     * input = public_input[i]\n                     * valid_inputs &= input < p\n                     * temp = input + gamma\n                     * numerator_value *= (β.σ(i) + wᵢ + γ)  // σ(i) = 0x05.ωⁱ\n                     * denominator_value *= (β.σ'(i) + wᵢ + γ) // σ'(i) = 0x0c.ωⁱ\n                     * root_1 *= ω\n                     * root_2 *= ω\n                     */\n\n                    let input := calldataload(public_inputs_ptr)\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\n                    let temp := addmod(input, gamma, p_clone)\n\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\n\n                    root_1 := mulmod(root_1, work_root, p_clone)\n                    root_2 := mulmod(root_2, work_root, p_clone)\n                }\n\n                // Revert if not all public inputs are field elements (i.e. < p)\n                if iszero(valid_inputs) {\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\n            }\n\n            /**\n             * Compute Plookup delta factor [γ(1 + β)]^{n-k}\n             * k = num roots cut out of Z_H = 4\n             */\n            {\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\n                let delta_numerator := delta_base\n                {\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {} lt(count, exponent) { count := add(count, count) } {\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\n                    }\n                }\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\n\n                let delta_denominator := mulmod(delta_base, delta_base, p)\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\n            }\n            /**\n             * Compute lagrange poly and vanishing poly fractions\n             */\n            {\n                /**\n                 * vanishing_numerator = zeta\n                 * ZETA_POW_N = zeta^n\n                 * vanishing_numerator -= 1\n                 * accumulating_root = omega_inverse\n                 * work_root = p - accumulating_root\n                 * domain_inverse = domain_inverse\n                 * vanishing_denominator = zeta + work_root\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\n                 * work_root = omega\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\n                 * l_start_denominator = zeta - 1\n                 * accumulating_root = work_root^2\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\n                 * Note: l_end_denominator term contains a term \\omega^5 to cut out 5 roots of unity from vanishing poly\n                 */\n\n                let zeta := mload(C_ZETA_LOC)\n\n                // compute zeta^n, where n is a power of 2\n                let vanishing_numerator := zeta\n                {\n                    // pow_small\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {} lt(count, exponent) { count := add(count, count) } {\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\n                    }\n                }\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\n\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\n                let work_root := sub(p, accumulating_root)\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\n\n                let vanishing_denominator := addmod(zeta, work_root, p)\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\n                vanishing_denominator :=\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\n\n                work_root := mload(OMEGA_LOC)\n\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\n\n                accumulating_root := mulmod(work_root, work_root, p)\n\n                let l_end_denominator :=\n                    addmod(\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\n                    )\n\n                /**\n                 * Compute inversions using Montgomery's batch inversion trick\n                 */\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\n                let t0 := accumulator\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n                let t1 := accumulator\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n                let t2 := accumulator\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n                let t3 := accumulator\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\n                let t4 := accumulator\n                {\n                    mstore(0, 0x20)\n                    mstore(0x20, 0x20)\n                    mstore(0x40, 0x20)\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\n                    mstore(0x80, sub(p, 2))\n                    mstore(0xa0, p)\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    accumulator := mload(0x00)\n                }\n\n                t4 := mulmod(accumulator, t4, p)\n                accumulator := mulmod(accumulator, l_end_denominator, p)\n\n                t3 := mulmod(accumulator, t3, p)\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\n\n                t2 := mulmod(accumulator, t2, p)\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n\n                t1 := mulmod(accumulator, t1, p)\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n\n                t0 := mulmod(accumulator, t0, p)\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\n\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\n            }\n\n            /**\n             * UltraPlonk Widget Ordering:\n             *\n             * 1. Permutation widget\n             * 2. Plookup widget\n             * 3. Arithmetic widget\n             * 4. Fixed base widget (?)\n             * 5. GenPermSort widget\n             * 6. Elliptic widget\n             * 7. Auxiliary widget\n             */\n\n            /**\n             * COMPUTE PERMUTATION WIDGET EVALUATION\n             */\n            {\n                let alpha := mload(C_ALPHA_LOC)\n                let beta := mload(C_BETA_LOC)\n                let gamma := mload(C_GAMMA_LOC)\n\n                /**\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\n                 * result = alpha_base * z_eval * t1 * t2\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\n                 */\n                let t1 :=\n                    mulmod(\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\n                        p\n                    )\n                let t2 :=\n                    mulmod(\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\n                        p\n                    )\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\n                t1 :=\n                    mulmod(\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\n                        p\n                    )\n                t2 :=\n                    mulmod(\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\n                        p\n                    )\n                result :=\n                    addmod(\n                        result,\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\n                        p\n                    )\n\n                /**\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_{n-k}(ʓ) . (z(ʓ.ω) - ∆_{PI}))\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_1(ʓ)(Z(ʓ) - 1))\n                 * alpha_Base *= alpha\n                 */\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n                result :=\n                    addmod(\n                        result,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(\n                                mload(L_END_LOC),\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n                mstore(\n                    PERMUTATION_IDENTITY,\n                    addmod(\n                        result,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\n                            p\n                        ),\n                        p\n                    )\n                )\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n            }\n\n            /**\n             * COMPUTE PLOOKUP WIDGET EVALUATION\n             */\n            {\n                /**\n                 * Goal: f = (w1(z) + q2.w1(zω)) + η(w2(z) + qm.w2(zω)) + η²(w3(z) + qc.w_3(zω)) + q3(z).η³\n                 * f = η.q3(z)\n                 * f += (w3(z) + qc.w_3(zω))\n                 * f *= η\n                 * f += (w2(z) + qm.w2(zω))\n                 * f *= η\n                 * f += (w1(z) + q2.w1(zω))\n                 */\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\n\n                // t(z) = table4(z).η³ + table3(z).η² + table2(z).η + table1(z)\n                let t :=\n                    addmod(\n                        addmod(\n                            addmod(\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\n                                p\n                            ),\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\n                            p\n                        ),\n                        mload(TABLE1_EVAL_LOC),\n                        p\n                    )\n\n                // t(zw) = table4(zw).η³ + table3(zw).η² + table2(zw).η + table1(zw)\n                let t_omega :=\n                    addmod(\n                        addmod(\n                            addmod(\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\n                                p\n                            ),\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\n                            p\n                        ),\n                        mload(TABLE1_OMEGA_EVAL_LOC),\n                        p\n                    )\n\n                /**\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + γ) * (t(z) + βt(zω) + γ(β + 1)) * (β + 1)\n                 * gamma_beta_constant = γ(β + 1)\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\n                 * temp0 = t(z) + t(zω) * β + gamma_beta_constant\n                 * numerator *= temp0\n                 * numerator *= (β + 1)\n                 * temp0 = alpha * l_1\n                 * numerator += temp0\n                 * numerator *= z_lookup(z)\n                 * numerator -= temp0\n                 */\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\n                numerator := mulmod(numerator, temp0, p)\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\n                numerator := addmod(numerator, temp0, p)\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\n                numerator := addmod(numerator, sub(p, temp0), p)\n\n                /**\n                 * Goal: denominator = z_lookup(zω)*[s(z) + βs(zω) + γ(1 + β)] - [z_lookup(zω) - [γ(1 + β)]^{n-k}]*α²L_end(z)\n                 * note: delta_factor = [γ(1 + β)]^{n-k}\n                 * denominator = s(z) + βs(zω) + γ(β + 1)\n                 * temp1 = α²L_end(z)\n                 * denominator -= temp1\n                 * denominator *= z_lookup(zω)\n                 * denominator += temp1 * delta_factor\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\n                 * alpha_base *= alpha^3\n                 */\n                let denominator :=\n                    addmod(\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\n                        gamma_beta_constant,\n                        p\n                    )\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\n                denominator := addmod(denominator, sub(p, temp1), p)\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\n\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\n            }\n\n            /**\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * The basic arithmetic gate identity in standard plonk is as follows.\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\n                 * However, for Ultraplonk, we extend this to support \"passing\" wires between rows (shown without alpha scaling below):\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\n                 * (q_arith - 1)*( α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\n                 *\n                 * This formula results in several cases depending on q_arith:\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\n                 *\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\n                 *\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\n                 *\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. α allows us to split\n                 * the equation into two:\n                 *\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\n                 *\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\n                 * The equation can be split into two:\n                 *\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0\n                 *\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\n                 * product.\n                 */\n\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\n\n                // @todo - Add a explicit test that hits QARITH == 3\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\n                let w1w2qm :=\n                    mulmod(\n                        mulmod(\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\n                            p\n                        ),\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\n                        p\n                    )\n\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\n                let identity :=\n                    addmod(\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\n                    )\n\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\n                // w_1 + w_4 - w_1_omega + q_m = 0\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\n                // α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\n                let extra_small_addition_gate_identity :=\n                    mulmod(\n                        mload(C_ALPHA_LOC),\n                        mulmod(\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\n                            addmod(\n                                mload(QM_EVAL_LOC),\n                                addmod(\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\n                mstore(\n                    ARITHMETIC_IDENTITY,\n                    mulmod(\n                        mload(C_ALPHA_BASE_LOC),\n                        mulmod(\n                            mload(QARITH_EVAL_LOC),\n                            addmod(\n                                identity,\n                                mulmod(\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\n                                    p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\n            }\n\n            /**\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\n             */\n            {\n                /**\n                 * D1 = (w2 - w1)\n                 * D2 = (w3 - w2)\n                 * D3 = (w4 - w3)\n                 * D4 = (w1_omega - w4)\n                 *\n                 * α_a = alpha_base\n                 * α_b = alpha_base * α\n                 * α_c = alpha_base * α^2\n                 * α_d = alpha_base * α^3\n                 *\n                 * range_accumulator = (\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).α_a +\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).α_b +\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).α_c +\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).α_d +\n                 * ) . q_sort\n                 */\n                let minus_two := sub(p, 2)\n                let minus_three := sub(p, 3)\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\n\n                let range_accumulator :=\n                    mulmod(\n                        mulmod(\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\n                            addmod(d1, minus_three, p),\n                            p\n                        ),\n                        mload(C_ALPHA_BASE_LOC),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\n                                addmod(d2, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\n                                addmod(d3, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\n                                addmod(d4, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\n\n                mstore(SORT_IDENTITY, range_accumulator)\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\n            }\n\n            /**\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\n                 * endo_sqr_term = x_2^2\n                 * endo_sqr_term *= (x_3 - x_1)\n                 * endo_sqr_term *= q_beta^2\n                 * leftovers = x_2^2\n                 * leftovers *= x_2\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\n                 * leftovers -= (y_2^2 + y_1^2)\n                 * sign_term = y_2 * y_1\n                 * sign_term += sign_term\n                 * sign_term *= q_sign\n                 */\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\n\n                let x_add_identity :=\n                    addmod(\n                        mulmod(\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\n                            mulmod(x_diff, x_diff, p),\n                            p\n                        ),\n                        addmod(\n                            sub(\n                                p,\n                                addmod(y2_sqr, y1_sqr, p)\n                            ),\n                            addmod(y1y2, y1y2, p),\n                            p\n                        ),\n                        p\n                    )\n                x_add_identity :=\n                    mulmod(\n                        mulmod(\n                            x_add_identity,\n                            addmod(\n                                1,\n                                sub(p, mload(QM_EVAL_LOC)),\n                                p\n                            ),\n                            p\n                        ),\n                        mload(C_ALPHA_BASE_LOC),\n                        p\n                    )\n\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let y1_plus_y3 := addmod(\n                    mload(Y1_EVAL_LOC),\n                    mload(Y3_EVAL_LOC),\n                    p\n                )\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\n                let y_add_identity :=\n                    addmod(\n                        mulmod(y1_plus_y3, x_diff, p),\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\n                        p\n                    )\n                y_add_identity :=\n                    mulmod(\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                        p\n                    )\n\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\n                )\n            }\n            {\n                /**\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\n                 * x_1_pow_4_mul_9 = x_pow_4;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_pow_4;\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\n                 */\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\n                let x_double_identity :=\n                    addmod(\n                        mulmod(\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\n                            y1_sqr_mul_4,\n                            p\n                        ),\n                        sub(p, x1_pow_4_mul_9),\n                        p\n                    )\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\n                let y_double_identity :=\n                    addmod(\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\n                        sub(\n                            p,\n                            mulmod(\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\n                                p\n                            )\n                        ),\n                        p\n                    )\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\n                y_double_identity :=\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY,\n                    addmod(\n                        mload(ELLIPTIC_IDENTITY),\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\n            }\n\n            /**\n             * COMPUTE AUXILIARY WIDGET EVALUATION\n             */\n            {\n                {\n                    /**\n                     * Non native field arithmetic gate 2\n                     *             _                                                                               _\n                     *            /   _                   _                               _       14                \\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\n                     *            \\_                                                                               _/\n                     *\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\n                     * non_native_field_gate_2 -= w_4_omega\n                     * non_native_field_gate_2 += limb_subproduct\n                     * non_native_field_gate_2 *= q_4\n                     * limb_subproduct *= limb_size\n                     * limb_subproduct += w_1_omega * w_2_omega\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\n                     */\n\n                    let limb_subproduct :=\n                        addmod(\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\n                            p\n                        )\n\n                    let non_native_field_gate_2 :=\n                        addmod(\n                            addmod(\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\n                                p\n                            ),\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\n                            p\n                        )\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\n                    limb_subproduct :=\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\n                    let non_native_field_gate_1 :=\n                        mulmod(\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\n                            mload(Q3_EVAL_LOC),\n                            p\n                        )\n                    let non_native_field_gate_3 :=\n                        mulmod(\n                            addmod(\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\n                                p\n                            ),\n                            mload(QM_EVAL_LOC),\n                            p\n                        )\n                    let non_native_field_identity :=\n                        mulmod(\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\n                            mload(Q2_EVAL_LOC),\n                            p\n                        )\n\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\n                }\n\n                {\n                    /**\n                     * limb_accumulator_1 = w_2_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_3;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_2;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1;\n                     * limb_accumulator_1 -= w_4;\n                     * limb_accumulator_1 *= q_4;\n                     */\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\n\n                    /**\n                     * limb_accumulator_2 = w_3_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_2_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_1_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_4;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_3;\n                     * limb_accumulator_2 -= w_4_omega;\n                     * limb_accumulator_2 *= q_m;\n                     */\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\n\n                    mstore(\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\n                    )\n                }\n\n                {\n                    /**\n                     * memory_record_check = w_3;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_2;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_1;\n                     * memory_record_check *= eta;\n                     * memory_record_check += q_c;\n                     *\n                     * partial_record_check = memory_record_check;\n                     *\n                     * memory_record_check -= w_4;\n                     */\n\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\n\n                    let partial_record_check := memory_record_check\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\n\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\n\n                    // index_delta = w_1_omega - w_1\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\n                    // record_delta = w_4_omega - w_4\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\n\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\n                    let adjacent_values_match_if_adjacent_indices_match :=\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\n\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\n                    mstore(\n                        AUX_ROM_CONSISTENCY_EVALUATION,\n                        addmod(\n                            mulmod(\n                                addmod(\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\n                                    index_is_monotonically_increasing,\n                                    p\n                                ),\n                                mload(C_ALPHA_LOC),\n                                p\n                            ),\n                            memory_record_check,\n                            p\n                        )\n                    )\n\n                    {\n                        /**\n                         * next_gate_access_type = w_3_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_2_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_1_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\n                         */\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\n\n                        // value_delta = w_3_omega - w_3\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\n\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\n                            mulmod(\n                                addmod(1, sub(p, index_delta), p),\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\n                                p\n                            )\n\n                        // AUX_RAM_CONSISTENCY_EVALUATION\n\n                        /**\n                         * access_type = w_4 - partial_record_check\n                         * access_check = access_type^2 - access_type\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += access_check;\n                         */\n\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\n                        let next_gate_access_type_is_boolean :=\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\n                        let RAM_cci :=\n                            mulmod(\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\n                                mload(C_ALPHA_LOC),\n                                p\n                            )\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(RAM_cci, access_check, p)\n\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\n                    }\n\n                    {\n                        // timestamp_delta = w_2_omega - w_2\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\n\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\n                        let RAM_timestamp_check_identity :=\n                            addmod(\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\n                            )\n\n                        /**\n                         * memory_identity = ROM_consistency_check_identity * q_2;\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\n                         * memory_identity += memory_record_check * q_m;\n                         * memory_identity *= q_1;\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\n                         *\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\n                         * auxiliary_identity *= q_aux;\n                         * auxiliary_identity *= alpha_base;\n                         */\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\n                        memory_identity :=\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\n                        memory_identity :=\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\n                        memory_identity :=\n                            addmod(\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\n                            )\n\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\n\n                        mstore(AUX_IDENTITY, auxiliary_identity)\n\n                        // update alpha\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\n                    }\n                }\n            }\n\n            {\n                /**\n                 * quotient = ARITHMETIC_IDENTITY\n                 * quotient += PERMUTATION_IDENTITY\n                 * quotient += PLOOKUP_IDENTITY\n                 * quotient += SORT_IDENTITY\n                 * quotient += ELLIPTIC_IDENTITY\n                 * quotient += AUX_IDENTITY\n                 * quotient *= ZERO_POLY_INVERSE\n                 */\n                mstore(\n                    QUOTIENT_EVAL_LOC,\n                    mulmod(\n                        addmod(\n                            addmod(\n                                addmod(\n                                    addmod(\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\n                                        mload(ARITHMETIC_IDENTITY),\n                                        p\n                                    ),\n                                    mload(SORT_IDENTITY),\n                                    p\n                                ),\n                                mload(ELLIPTIC_IDENTITY),\n                                p\n                            ),\n                            mload(AUX_IDENTITY),\n                            p\n                        ),\n                        mload(ZERO_POLY_INVERSE_LOC),\n                        p\n                    )\n                )\n            }\n\n            /**\n             * GENERATE NU AND SEPARATOR CHALLENGES\n             */\n            {\n                let current_challenge := mload(C_CURRENT_LOC)\n                // get a calldata pointer that points to the start of the data we want to copy\n                let calldata_ptr := add(calldataload(0x04), 0x24)\n\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\n\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\n\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\n\n                mstore(C_V0_LOC, mod(challenge, p))\n                // We need THIRTY-ONE independent nu challenges!\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x02)\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x03)\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x04)\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x05)\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x06)\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x07)\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x08)\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x09)\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0a)\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0b)\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0c)\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0d)\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0e)\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0f)\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x10)\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x11)\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x12)\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x13)\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x14)\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x15)\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x16)\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x17)\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x18)\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x19)\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1a)\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1b)\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1c)\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1d)\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\n\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\n                mstore8(0x20, 0x1d)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_V30_LOC, mod(challenge, p))\n\n                // separator\n                mstore(0x00, challenge)\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\n\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\n            }\n\n            let success := 0\n            // VALIDATE T1\n            {\n                let x := mload(T1_X_LOC)\n                let y := mload(T1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(ACCUMULATOR_X_LOC, x)\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\n            }\n            // VALIDATE T2\n            {\n                let x := mload(T2_X_LOC) // 0x1400\n                let y := mload(T2_Y_LOC) // 0x1420\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(ZETA_POW_N_LOC))\n            // accumulator_2 = [T2].zeta^n\n            success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            // accumulator = [T1] + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE T3\n            {\n                let x := mload(T3_X_LOC)\n                let y := mload(T3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\n            // accumulator_2 = [T3].zeta^{2n}\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE T4\n            {\n                let x := mload(T4_X_LOC)\n                let y := mload(T4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\n            // accumulator_2 = [T4].zeta^{3n}\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W1\n            {\n                let x := mload(W1_X_LOC)\n                let y := mload(W1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\n            // accumulator_2 = v0.(u + 1).[W1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W2\n            {\n                let x := mload(W2_X_LOC)\n                let y := mload(W2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\n            // accumulator_2 = v1.(u + 1).[W2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W3\n            {\n                let x := mload(W3_X_LOC)\n                let y := mload(W3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\n            // accumulator_2 = v2.(u + 1).[W3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W4\n            {\n                let x := mload(W4_X_LOC)\n                let y := mload(W4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\n            // accumulator_2 = v3.(u + 1).[W4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE S\n            {\n                let x := mload(S_X_LOC)\n                let y := mload(S_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\n            // accumulator_2 = v4.(u + 1).[S]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE Z\n            {\n                let x := mload(Z_X_LOC)\n                let y := mload(Z_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\n            // accumulator_2 = v5.(u + 1).[Z]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE Z_LOOKUP\n            {\n                let x := mload(Z_LOOKUP_X_LOC)\n                let y := mload(Z_LOOKUP_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q1_X_LOC))\n            mstore(0x20, mload(Q1_Y_LOC))\n            mstore(0x40, mload(C_V7_LOC))\n            // accumulator_2 = v7.[Q1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q2_X_LOC))\n            mstore(0x20, mload(Q2_Y_LOC))\n            mstore(0x40, mload(C_V8_LOC))\n            // accumulator_2 = v8.[Q2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q3\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q3_X_LOC))\n            mstore(0x20, mload(Q3_Y_LOC))\n            mstore(0x40, mload(C_V9_LOC))\n            // accumulator_2 = v9.[Q3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q4\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q4_X_LOC))\n            mstore(0x20, mload(Q4_Y_LOC))\n            mstore(0x40, mload(C_V10_LOC))\n            // accumulator_2 = v10.[Q4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QM\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QM_X_LOC))\n            mstore(0x20, mload(QM_Y_LOC))\n            mstore(0x40, mload(C_V11_LOC))\n            // accumulator_2 = v11.[Q;]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QC\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QC_X_LOC))\n            mstore(0x20, mload(QC_Y_LOC))\n            mstore(0x40, mload(C_V12_LOC))\n            // accumulator_2 = v12.[QC]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QARITH\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QARITH_X_LOC))\n            mstore(0x20, mload(QARITH_Y_LOC))\n            mstore(0x40, mload(C_V13_LOC))\n            // accumulator_2 = v13.[QARITH]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QSORT\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QSORT_X_LOC))\n            mstore(0x20, mload(QSORT_Y_LOC))\n            mstore(0x40, mload(C_V14_LOC))\n            // accumulator_2 = v14.[QSORT]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QELLIPTIC\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QELLIPTIC_X_LOC))\n            mstore(0x20, mload(QELLIPTIC_Y_LOC))\n            mstore(0x40, mload(C_V15_LOC))\n            // accumulator_2 = v15.[QELLIPTIC]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QAUX\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QAUX_X_LOC))\n            mstore(0x20, mload(QAUX_Y_LOC))\n            mstore(0x40, mload(C_V16_LOC))\n            // accumulator_2 = v15.[Q_AUX]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA1_X_LOC))\n            mstore(0x20, mload(SIGMA1_Y_LOC))\n            mstore(0x40, mload(C_V17_LOC))\n            // accumulator_2 = v17.[sigma1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA2_X_LOC))\n            mstore(0x20, mload(SIGMA2_Y_LOC))\n            mstore(0x40, mload(C_V18_LOC))\n            // accumulator_2 = v18.[sigma2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA3_X_LOC))\n            mstore(0x20, mload(SIGMA3_Y_LOC))\n            mstore(0x40, mload(C_V19_LOC))\n            // accumulator_2 = v19.[sigma3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA4_X_LOC))\n            mstore(0x20, mload(SIGMA4_Y_LOC))\n            mstore(0x40, mload(C_V20_LOC))\n            // accumulator_2 = v20.[sigma4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE1_X_LOC))\n            mstore(0x20, mload(TABLE1_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\n            // accumulator_2 = u.[table1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE2_X_LOC))\n            mstore(0x20, mload(TABLE2_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\n            // accumulator_2 = u.[table2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE3_X_LOC))\n            mstore(0x20, mload(TABLE3_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\n            // accumulator_2 = u.[table3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE4_X_LOC))\n            mstore(0x20, mload(TABLE4_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\n            // accumulator_2 = u.[table4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE_TYPE\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE_TYPE_X_LOC))\n            mstore(0x20, mload(TABLE_TYPE_Y_LOC))\n            mstore(0x40, mload(C_V25_LOC))\n            // accumulator_2 = v25.[TableType]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID1_X_LOC))\n            mstore(0x20, mload(ID1_Y_LOC))\n            mstore(0x40, mload(C_V26_LOC))\n            // accumulator_2 = v26.[ID1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID2_X_LOC))\n            mstore(0x20, mload(ID2_Y_LOC))\n            mstore(0x40, mload(C_V27_LOC))\n            // accumulator_2 = v27.[ID2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID3_X_LOC))\n            mstore(0x20, mload(ID3_Y_LOC))\n            mstore(0x40, mload(C_V28_LOC))\n            // accumulator_2 = v28.[ID3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID4_X_LOC))\n            mstore(0x20, mload(ID4_Y_LOC))\n            mstore(0x40, mload(C_V29_LOC))\n            // accumulator_2 = v29.[ID4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            /**\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\n             */\n            {\n                /**\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\n                 */\n                let batch_evaluation :=\n                    mulmod(\n                        mload(C_V0_LOC),\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V1_LOC),\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V2_LOC),\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V3_LOC),\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V4_LOC),\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V5_LOC),\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V6_LOC),\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n\n                /**\n                 * batch_evaluation += v7 * Q1_EVAL\n                 * batch_evaluation += v8 * Q2_EVAL\n                 * batch_evaluation += v9 * Q3_EVAL\n                 * batch_evaluation += v10 * Q4_EVAL\n                 * batch_evaluation += v11 * QM_EVAL\n                 * batch_evaluation += v12 * QC_EVAL\n                 * batch_evaluation += v13 * QARITH_EVAL\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\n                 */\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\n\n                /**\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\n                 * batch_evaluation += v25 * table_type_eval\n                 * batch_evaluation += v26 * id1_eval\n                 * batch_evaluation += v27 * id2_eval\n                 * batch_evaluation += v28 * id3_eval\n                 * batch_evaluation += v29 * id4_eval\n                 * batch_evaluation += quotient_eval\n                 */\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V21_LOC),\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V22_LOC),\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V23_LOC),\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V24_LOC),\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\n\n                mstore(0x00, 0x01) // [1].x\n                mstore(0x20, 0x02) // [1].y\n                mstore(0x40, sub(p, batch_evaluation))\n                // accumulator_2 = -[1].(batch_evaluation)\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n                if iszero(success) {\n                    mstore(0x0, OPENING_COMMITMENT_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            /**\n             * PERFORM PAIRING PREAMBLE\n             */\n            {\n                let u := mload(C_U_LOC)\n                let zeta := mload(C_ZETA_LOC)\n                // VALIDATE PI_Z\n                {\n                    let x := mload(PI_Z_X_LOC)\n                    let y := mload(PI_Z_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                // compute zeta.[PI_Z] and add into accumulator\n                mstore(0x40, zeta)\n                success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n                // VALIDATE PI_Z_OMEGA\n                {\n                    let x := mload(PI_Z_OMEGA_X_LOC)\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n                // PAIRING_RHS = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\n\n                mstore(0x00, mload(PI_Z_X_LOC))\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, u)\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\n                // negate lhs y-coordinate\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\n\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    // VALIDATE RECURSIVE P1\n                    {\n                        let x := mload(RECURSIVE_P1_X_LOC)\n                        let y := mload(RECURSIVE_P1_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                            revert(0x00, 0x04)\n                        }\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n\n                    // compute u.u.[recursive_p1] and write into 0x60\n                    mstore(0x40, mulmod(u, u, p))\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\n                    // VALIDATE RECURSIVE P2\n                    {\n                        let x := mload(RECURSIVE_P2_X_LOC)\n                        let y := mload(RECURSIVE_P2_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                            revert(0x00, 0x04)\n                        }\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n                    // compute u.u.[recursive_p2] and write into 0x00\n                    // 0x40 still contains u*u\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\n\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\n\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\n                }\n\n                if iszero(success) {\n                    mstore(0x0, PAIRING_PREAMBLE_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            /**\n             * PERFORM PAIRING\n             */\n            {\n                // rhs paired with [1]_2\n                // lhs paired with [x]_2\n\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\n                mstore(0x100, mload(G2X_X0_LOC))\n                mstore(0x120, mload(G2X_X1_LOC))\n                mstore(0x140, mload(G2X_Y0_LOC))\n                mstore(0x160, mload(G2X_Y1_LOC))\n\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\n                if iszero(and(success, mload(0x00))) {\n                    mstore(0x0, PAIRING_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            {\n                mstore(0x00, 0x01)\n                return(0x00, 0x20) // Proof succeeded!\n            }\n        }\n    }\n}\n\ncontract UltraVerifier is BaseUltraVerifier {\n    function getVerificationKeyHash() public pure override(BaseUltraVerifier) returns (bytes32) {\n        return UltraVerificationKey.verificationKeyHash();\n    }\n\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(BaseUltraVerifier) {\n        UltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\n    }\n}\n"
    },
    "contracts/NonSybilERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\nimport \"./merkle/plonk_vk.sol\";\n\ncontract NonSybilERC20 is ERC20, ERC20Permit {\n    UltraVerifier public verifier;\n\n    mapping(bytes32 => bool) public nullifiers;\n\n    constructor(\n        address _verifier\n    ) ERC20(\"MyToken\", \"MTK\") ERC20Permit(\"MyToken\") {\n        verifier = UltraVerifier(_verifier);\n    }\n\n    function mint(\n        address to,\n        bytes calldata _proof,\n        bytes32[] calldata _publicInputs\n    ) public {\n        require(!nullifiers[_publicInputs[1]], \"Nullifier used\");\n        require(verifier.verify(_proof, _publicInputs), \"Invalid proof\");\n        nullifiers[_publicInputs[1]] = true;\n        _mint(to, 100e18);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}